{"version":3,"sources":["../src/index.ts","../src/safe-float.ts","../src/safe-string.ts"],"sourcesContent":["export * from \"./safe-float\";\nexport * from \"./safe-string\";\n","import { types } from \"node:util\";\n\n/**\n * If the given arg is:\n * - a number (finite): returns it\n * - an array: calls safeFloat on the first element\n * - a string: tries to parse it as a float => returns it if it is finite, 0 otherwise\n * - anything else: returns 0\n *\n * @param arg\n * @returns\n */\nexport function safeFloat(arg: unknown): number {\n  return safeFloatWithDefault(arg, 0);\n}\n\n/**\n * If the given arg is:\n * - a number (finite): returns it\n * - an array: calls safeFloatWithDefault on the first element\n * - a string: tries to parse it as a float => returns it if it is finite, the given defaultValue otherwise\n * - anything else: returns the given defaultValue\n *\n * @param arg\n * @param defaultValue\n * @returns\n */\nexport function safeFloatWithDefault<T extends number | null>(arg: unknown, defaultValue: T): number | T {\n  if (typeof arg === \"number\" && Number.isFinite(arg)) {\n    return arg;\n  }\n\n  if (Array.isArray(arg)) {\n    return safeFloatWithDefault(arg[0], defaultValue);\n  }\n\n  if (types.isSet(arg)) {\n    return safeFloatWithDefault(Array.from(arg)[0], defaultValue);\n  }\n\n  if (typeof arg === \"bigint\") {\n    return arg.valueOf() > Number.MAX_VALUE ? Number.MAX_VALUE : Number(arg.valueOf());\n  }\n\n  if (typeof arg === \"string\") {\n    // try to parse it\n    const parsed = Number.parseFloat(arg);\n    return Number.isFinite(parsed) ? parsed : defaultValue;\n  }\n\n  return defaultValue;\n}\n\n/**\n * Calls safeFloat on each element of the given list (array or set)\n * If it is not an array, it wraps it in an array and calls safeFloat on the first element\n */\nexport function safeFloats(arg: unknown): number[] {\n  return safeFloatsWithDefault(arg, 0);\n}\n\n/**\n * Calls safeFloatWithDefault on each element of the given list (array or set)\n * If it is not an array, it wraps it in an array and calls safeFloatWithDefault on the first element\n */\nexport function safeFloatsWithDefault<T extends number | null>(arg: unknown, defaultValue: T): Array<number | T> {\n  const list = Array.isArray(arg) ? arg : types.isSet(arg) ? [...arg] : [arg];\n  return list.map((x) => safeFloatWithDefault(x, defaultValue));\n}\n","import { types } from \"node:util\";\nimport { safeCompact } from \"@plandek-utils/safe-compact\";\nimport { isDayjs } from \"@plandek-utils/ts-parse-dayjs\";\n\n/**\n * If the argument is:\n * - a string, return it.\n * - a number or bigint, return its string representation.\n * - a Date or a Dayjs, return its ISO string.\n * - an array, return the safe string of its first element.\n *\n * Otherwise, return an empty string.\n *\n * @param arg\n * @returns\n */\nexport function safeString(arg: unknown): string {\n  if (typeof arg === \"string\") {\n    return arg;\n  }\n\n  if (typeof arg === \"number\") {\n    return Number.isFinite(arg) ? arg.toString() : \"\";\n  }\n\n  if (typeof arg === \"bigint\") {\n    return arg.toString();\n  }\n\n  if (Array.isArray(arg)) {\n    return safeString(arg[0]);\n  }\n\n  if (types.isSet(arg)) {\n    return safeString(Array.from(arg as Set<unknown>)[0]);\n  }\n\n  if (types.isDate(arg)) {\n    return arg.toISOString();\n  }\n\n  if (isDayjs(arg)) {\n    return arg.toISOString();\n  }\n\n  return \"\";\n}\n\n/**\n * Calls `safeString` and returns the response, unless it is an empty string, in which case it returns null.\n *\n * @param arg\n * @returns\n */\nexport function safeStringIfPresent(arg: unknown): string | null {\n  const result = safeString(arg);\n  return result === \"\" ? null : result;\n}\n\n/**\n * Wraps the given argument in an array, unless it is already an array. If it is a Set it converts it into an array. Then calls safeString on each element. It removes nulls and undefined before returning the result.\n * @param arg\n * @returns\n */\nexport function safeStrings(arg: unknown): string[] {\n  const list = Array.isArray(arg) ? arg : types.isSet(arg) ? Array.from(arg as Set<unknown>) : [arg];\n  return safeCompact(list.map(safeString));\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,uBAAsB;AAYf,SAAS,UAAU,KAAsB;AAC9C,SAAO,qBAAqB,KAAK,CAAC;AACpC;AAaO,SAAS,qBAA8C,KAAc,cAA6B;AACvG,MAAI,OAAO,QAAQ,YAAY,OAAO,SAAS,GAAG,GAAG;AACnD,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,WAAO,qBAAqB,IAAI,CAAC,GAAG,YAAY;AAAA,EAClD;AAEA,MAAI,uBAAM,MAAM,GAAG,GAAG;AACpB,WAAO,qBAAqB,MAAM,KAAK,GAAG,EAAE,CAAC,GAAG,YAAY;AAAA,EAC9D;AAEA,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAO,IAAI,QAAQ,IAAI,OAAO,YAAY,OAAO,YAAY,OAAO,IAAI,QAAQ,CAAC;AAAA,EACnF;AAEA,MAAI,OAAO,QAAQ,UAAU;AAE3B,UAAM,SAAS,OAAO,WAAW,GAAG;AACpC,WAAO,OAAO,SAAS,MAAM,IAAI,SAAS;AAAA,EAC5C;AAEA,SAAO;AACT;AAMO,SAAS,WAAW,KAAwB;AACjD,SAAO,sBAAsB,KAAK,CAAC;AACrC;AAMO,SAAS,sBAA+C,KAAc,cAAoC;AAC/G,QAAM,OAAO,MAAM,QAAQ,GAAG,IAAI,MAAM,uBAAM,MAAM,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG;AAC1E,SAAO,KAAK,IAAI,CAAC,MAAM,qBAAqB,GAAG,YAAY,CAAC;AAC9D;;;ACpEA,IAAAA,oBAAsB;AACtB,0BAA4B;AAC5B,4BAAwB;AAcjB,SAAS,WAAW,KAAsB;AAC/C,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAO,OAAO,SAAS,GAAG,IAAI,IAAI,SAAS,IAAI;AAAA,EACjD;AAEA,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAO,IAAI,SAAS;AAAA,EACtB;AAEA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,WAAO,WAAW,IAAI,CAAC,CAAC;AAAA,EAC1B;AAEA,MAAI,wBAAM,MAAM,GAAG,GAAG;AACpB,WAAO,WAAW,MAAM,KAAK,GAAmB,EAAE,CAAC,CAAC;AAAA,EACtD;AAEA,MAAI,wBAAM,OAAO,GAAG,GAAG;AACrB,WAAO,IAAI,YAAY;AAAA,EACzB;AAEA,UAAI,+BAAQ,GAAG,GAAG;AAChB,WAAO,IAAI,YAAY;AAAA,EACzB;AAEA,SAAO;AACT;AAQO,SAAS,oBAAoB,KAA6B;AAC/D,QAAM,SAAS,WAAW,GAAG;AAC7B,SAAO,WAAW,KAAK,OAAO;AAChC;AAOO,SAAS,YAAY,KAAwB;AAClD,QAAM,OAAO,MAAM,QAAQ,GAAG,IAAI,MAAM,wBAAM,MAAM,GAAG,IAAI,MAAM,KAAK,GAAmB,IAAI,CAAC,GAAG;AACjG,aAAO,iCAAY,KAAK,IAAI,UAAU,CAAC;AACzC;","names":["import_node_util"]}