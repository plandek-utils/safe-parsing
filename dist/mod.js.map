{"version":3,"sources":["../src/safe-float.ts","../src/safe-string.ts"],"sourcesContent":["import { types } from \"node:util\";\n\n/**\n * If the given arg is:\n * - a number (finite): returns it\n * - an array: calls safeFloat on the first element\n * - a string: tries to parse it as a float => returns it if it is finite, 0 otherwise\n * - anything else: returns 0\n *\n * @param arg\n * @returns\n */\nexport function safeFloat(arg: unknown): number {\n\treturn safeFloatWithDefault(arg, 0);\n}\n\n/**\n * If the given arg is:\n * - a number (finite): returns it\n * - an array: calls safeFloatWithDefault on the first element\n * - a string: tries to parse it as a float => returns it if it is finite, the given defaultValue otherwise\n * - anything else: returns the given defaultValue\n *\n * @param arg\n * @param defaultValue\n * @returns\n */\nexport function safeFloatWithDefault<T extends number | null>(\n\targ: unknown,\n\tdefaultValue: T,\n): number | T {\n\tif (typeof arg === \"number\" && Number.isFinite(arg)) {\n\t\treturn arg;\n\t}\n\n\tif (Array.isArray(arg)) {\n\t\treturn safeFloatWithDefault(arg[0], defaultValue);\n\t}\n\n\tif (types.isSet(arg)) {\n\t\treturn safeFloatWithDefault(Array.from(arg)[0], defaultValue);\n\t}\n\n\tif (typeof arg === \"bigint\") {\n\t\treturn arg.valueOf() > Number.MAX_VALUE\n\t\t\t? Number.MAX_VALUE\n\t\t\t: Number(arg.valueOf());\n\t}\n\n\tif (typeof arg === \"string\") {\n\t\t// try to parse it\n\t\tconst parsed = parseFloat(arg);\n\t\treturn Number.isFinite(parsed) ? parsed : defaultValue;\n\t}\n\n\treturn defaultValue;\n}\n\n/**\n * Calls safeFloat on each element of the given list (array or set)\n * If it is not an array, it wraps it in an array and calls safeFloat on the first element\n */\nexport function safeFloats(arg: unknown): number[] {\n\treturn safeFloatsWithDefault(arg, 0);\n}\n\n/**\n * Calls safeFloatWithDefault on each element of the given list (array or set)\n * If it is not an array, it wraps it in an array and calls safeFloatWithDefault on the first element\n */\nexport function safeFloatsWithDefault<T extends number | null>(\n\targ: unknown,\n\tdefaultValue: T,\n): Array<number | T> {\n\tconst list = Array.isArray(arg) ? arg : types.isSet(arg) ? [...arg] : [arg];\n\treturn list.map((x) => safeFloatWithDefault(x, defaultValue));\n}\n","import { safeCompact } from \"@plandek-utils/safe-compact\";\nimport { isDayjs } from \"@plandek-utils/ts-parse-dayjs\";\nimport { types } from \"node:util\";\n\n/**\n * If the argument is:\n * - a string, return it.\n * - a number or bigint, return its string representation.\n * - a Date or a Dayjs, return its ISO string.\n * - an array, return the safe string of its first element.\n *\n * Otherwise, return an empty string.\n *\n * @param arg\n * @returns\n */\nexport function safeString(arg: unknown): string {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t}\n\n\tif (typeof arg === \"number\") {\n\t\treturn Number.isFinite(arg) ? arg.toString() : \"\";\n\t}\n\n\tif (typeof arg === \"bigint\") {\n\t\treturn arg.toString();\n\t}\n\n\tif (Array.isArray(arg)) {\n\t\treturn safeString(arg[0]);\n\t}\n\n\tif (types.isSet(arg)) {\n\t\treturn safeString(Array.from(arg as Set<unknown>)[0]);\n\t}\n\n\tif (types.isDate(arg)) {\n\t\treturn arg.toISOString();\n\t}\n\n\tif (isDayjs(arg)) {\n\t\treturn arg.toISOString();\n\t}\n\n\treturn \"\";\n}\n\n/**\n * Calls `safeString` and returns the response, unless it is an empty string, in which case it returns null.\n *\n * @param arg\n * @returns\n */\nexport function safeStringIfPresent(arg: unknown): string | null {\n\tconst result = safeString(arg);\n\treturn result === \"\" ? null : result;\n}\n\n/**\n * Wraps the given argument in an array, unless it is already an array. If it is a Set it converts it into an array. Then calls safeString on each element. It removes nulls and undefined before returning the result.\n * @param arg\n * @returns\n */\nexport function safeStrings(arg: unknown): string[] {\n\tconst list = Array.isArray(arg)\n\t\t? arg\n\t\t: types.isSet(arg)\n\t\t\t? Array.from(arg as Set<unknown>)\n\t\t\t: [arg];\n\treturn safeCompact(list.map(safeString));\n}\n"],"mappings":";AAAA,SAAS,aAAa;AAYf,SAAS,UAAU,KAAsB;AAC/C,SAAO,qBAAqB,KAAK,CAAC;AACnC;AAaO,SAAS,qBACf,KACA,cACa;AACb,MAAI,OAAO,QAAQ,YAAY,OAAO,SAAS,GAAG,GAAG;AACpD,WAAO;AAAA,EACR;AAEA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,WAAO,qBAAqB,IAAI,CAAC,GAAG,YAAY;AAAA,EACjD;AAEA,MAAI,MAAM,MAAM,GAAG,GAAG;AACrB,WAAO,qBAAqB,MAAM,KAAK,GAAG,EAAE,CAAC,GAAG,YAAY;AAAA,EAC7D;AAEA,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO,IAAI,QAAQ,IAAI,OAAO,YAC3B,OAAO,YACP,OAAO,IAAI,QAAQ,CAAC;AAAA,EACxB;AAEA,MAAI,OAAO,QAAQ,UAAU;AAE5B,UAAM,SAAS,WAAW,GAAG;AAC7B,WAAO,OAAO,SAAS,MAAM,IAAI,SAAS;AAAA,EAC3C;AAEA,SAAO;AACR;AAMO,SAAS,WAAW,KAAwB;AAClD,SAAO,sBAAsB,KAAK,CAAC;AACpC;AAMO,SAAS,sBACf,KACA,cACoB;AACpB,QAAM,OAAO,MAAM,QAAQ,GAAG,IAAI,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG;AAC1E,SAAO,KAAK,IAAI,CAAC,MAAM,qBAAqB,GAAG,YAAY,CAAC;AAC7D;;;AC5EA,SAAS,mBAAmB;AAC5B,SAAS,eAAe;AACxB,SAAS,SAAAA,cAAa;AAcf,SAAS,WAAW,KAAsB;AAChD,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO;AAAA,EACR;AAEA,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO,OAAO,SAAS,GAAG,IAAI,IAAI,SAAS,IAAI;AAAA,EAChD;AAEA,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO,IAAI,SAAS;AAAA,EACrB;AAEA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,WAAO,WAAW,IAAI,CAAC,CAAC;AAAA,EACzB;AAEA,MAAIA,OAAM,MAAM,GAAG,GAAG;AACrB,WAAO,WAAW,MAAM,KAAK,GAAmB,EAAE,CAAC,CAAC;AAAA,EACrD;AAEA,MAAIA,OAAM,OAAO,GAAG,GAAG;AACtB,WAAO,IAAI,YAAY;AAAA,EACxB;AAEA,MAAI,QAAQ,GAAG,GAAG;AACjB,WAAO,IAAI,YAAY;AAAA,EACxB;AAEA,SAAO;AACR;AAQO,SAAS,oBAAoB,KAA6B;AAChE,QAAM,SAAS,WAAW,GAAG;AAC7B,SAAO,WAAW,KAAK,OAAO;AAC/B;AAOO,SAAS,YAAY,KAAwB;AACnD,QAAM,OAAO,MAAM,QAAQ,GAAG,IAC3B,MACAA,OAAM,MAAM,GAAG,IACd,MAAM,KAAK,GAAmB,IAC9B,CAAC,GAAG;AACR,SAAO,YAAY,KAAK,IAAI,UAAU,CAAC;AACxC;","names":["types"]}